\documentclass[french,a4paper,openany,12pt]{book}
\usepackage{fontspec}
\setmainfont{Cardo}
\setmonofont{Fira Code}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage[french]{babel}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{titlesec}

\lstset{basicstyle=\ttfamily}
\titlespacing{\section}{16pt}{8pt}{0pt}
\titlespacing{\subsection}{16pt}{8pt}{0pt}
\titlespacing{\subsubsection}{8pt}{4pt}{0pt}

\title{Compte-rendu à t=2.0y}
\author{Jean-Michaël Celerier}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}
Ce document survole les travaux qui ont été réalisés jusqu'à présent 
lors de la thèse, étudie les pistes qui sont ouvertes et les possibilités 
pour la dernière année.

\section{Mise en relation avec le sujet}
Calques audio interactifs : \textbf{théorie}, mise en œuvre et usages.

\section{Articulation et analyse générale}
\chapter{Réalisations}

\section{Étude de cas}
\subsection{Sonopluie}
Ce cas est constitué de zones pré-écrites qui correspondent à des 
étapes d'une randonnée géo-localisée.

Le signal d'entrée est un positionnement GPS.

Les ambiances sonores évoluent selon les zones.
Il doit y avoir une forme d'interaction multi-pointeurs : 
par exemple, quand deux personnes sont dans la même zone, la scénarisation 
locale du son peut évoluer.

Pour l'écriture, il est utile d'avoir accès à une source de données cartographiques, 
comme Google Maps, MapQuest, etc.

\subsection{Tableaux sonores}
Dans ce cas, on travaille sur des tableaux que l'on désire sonifier, d'une manière 
artistique et avec une notion de scénarisation.

On interagit à l'aide d'une surface tactile ou d'un capteur de mouvements.

La scénarisation est définie de manière hiérarchique :
\begin{itemize}
    \item Une ambiance globale peut recouvrir tout le tableau.
    \item Comme dans le cas Sonopluie, des zones plus spécifiques peuvent porter une ambiance additionnelle.
    \item Des éléments individuels (objets) peuvent avoir un comportement qui leur est propre.
\end{itemize} 

\subsubsection{Bosch}
Ce triptyque riche en détails permet d'essayer différentes techniques.
\begin{itemize}
\item Spatialisation d'éléments statiques : bruits d'oiseaux, etc.
\item Spatialisation d'objets dynamiques : cercle du panneau central.
\item Instruments de musique : répartis dans le panneau de droite.
\item Historique avec personnages : foule en bas du panneau central.
\end{itemize}

\subsubsection{Tableaux de Vernet}
- Profondeur
- Refaire en vrai ? 
- Le tableau ne correspond pas à la réalité

\subsection{Jardin connecté}

\subsection{Pièces électro-acoustiques spatialisées}

\subsection{Grapholine}

\section{Développements théoriques, publications}
\subsection{États de l'art}
- Comparaison avec ce qui existe déjà

\subsection{Modèle théorique}
\subsubsection{TENOR2015: OSSIA}
Présente une spécification en réseaux de Petri des travaux réalisés 
lors du projet OSSIA.

\subsubsection{IUI2015 (refusé)}
\subsubsection{JNMR: Vérification}
Traduction du modèle graphique en automates temporisés tels que définis par J. Arias.

On essaye par la suite de permettre aux compositeurs de vérifier des propriétés 
sur leurs partitions interactives, telles que "deux séquences ne sont jamais exécutées en même temps".

\subsubsection{JIM2016: Interface}
Étude d'un scénario complexe (Cas du coureur, au futuroscope).

\subsubsection{ICMC2016: Programmation structurée}
"Design patterns" et outils de programmation standard à l'aide des objets présentés précédemment.

Démo : inspiré de Klavierstücke XI.

i-score qui communique par WebSockets avec un serveur Node.JS

Des gens se connectent par téléphone au serveur et peuvent influer sur 
l'exécution du scénario : prochaine partie à jouer, et vitesse moyenne de lecture.

\subsection{Espace}
\subsubsection{Compte-rendu espace}

\subsubsection{JIM2016: Espace}
Analyse de différentes méthodes pour représenter des objets spatiaux dans le cadre de i-score.
-> Conclusion : CAS peu adéquat, dur d'avoir de bonnes performances à un tick rate quelconque.
Alternatives : se restreindre aux cas linéaires ? 
GPU ? Mais latence.

\subsubsection{JIM2016: Démo}
% TODO la mettre sur scholar
Présentation d'une sonification interactive du tableau de Jérôme Bosch, \textit{Le Jardin des Délices}.

\subsection{Audio}
\subsubsection{SMC2016: i-score et LibAudioStream}
Intégration de la LibAudioStream avec i-score : traduction 
de scénarios i-score en expressions LibAudioStream et synchronisation
des deux moteurs d'exécution; outils graphiques pour le son.

Démo : toutes les fonctionnalités.

\subsection{Répartition}
\subsubsection{Stage master}
Proposition : méthode de répartition en introduisant de nouveaux réseaux de Petri.

\subsubsection{Étude subséquente : se baser sur modèle OSSIA}
On essaye d'implémenter le même formalisme, en utilisant non plus sur les réseaux de Petri, 
mais sur les outils dont on dispose dans le modèle OSSIA : TimeNode, Event, Trigger.

\section{Conférences, présentations, workshops}
\begin{itemize}
    \item \textbf{Cycles SCRIME 2014}
    Présentation du travail de stage sur la répartition.
    \item \textbf{Cycles SCRIME 2015}
    Présentation d'un état de l'art sur l'espace.
    \item \textbf{Forum IRCAM 2015}
    Présentation générale du logiciel.
    \item \textbf{FOSDEM 2016}
    Présentation générale du logiciel à l'aide d'un example réalisé par Théo en Processing.
    \item \textbf{GDR ESARS}
    Présentation générale du logiciel.
    \item \textbf{Cycles SCRIME 2016}
    Présentation du travail sur l'audio.
    \item \textbf{Workshop improvisation LaBRI}
    Présentation du travail sur l'audio.
    \item \textbf{Workshop DESINC2016}
    Workshop d'initiation à i-score avec des participants d'horizons variés.
\end{itemize}
\section{Développements logiciels}

\subsection{Génie logiciel et généralités}
\subsubsection{Performances}
Comment mettre en valeur l'aspect "performances" du logiciel ? 
Un accent très fort est mis dessus lors du développement.

Par exemple : 
\begin{itemize}
    \item Gestion du cache et de la mémoire via une minimisation des allocations dynamiques.
    \item Métaprogrammation et utilisation de techniques permettant de déporter le plus 
    de code possible à la compilation plutôt qu'à l'exécution pour améliorer les optimisations
    possibles par le compilateur.
    \begin{itemize}
        \item Dans libossia, gestion des types "tableaux" courants (\lstinline|Vec2f|, \lstinline|Vec3f|, \lstinline|Vec4f|) sur la pile plutôt que sur le tas. 
        C'est par opposition à Jamoma ou le type \lstinline|TTValue| est sur le tas et nécessite une allocation dynamique quoi qu'il arrive.
        \item Utilisation de ces types pour les dataspaces.
        \item Dans i-score, instantiation des composants du logiciel.
    \end{itemize}
    \item Structures de données optimisées au cas par cas.
    \item Caches variés pour améliorer les performances.
\end{itemize}

\subsubsection{Tests}
Couverture de code : 

\begin{itemize}
    \item 70 \% pour libossia via des tests unitaires et d'intégration.
    \item 50 \% pour i-score via des tests d'intégration.
    \item 0 \% pour les extensions à i-score (audio, espace, etc.).
\end{itemize}

Idéalement il devrait y avoir au moins 90\% de couverture.

Mais plus de tests implique moins de R\&D.

\subsection{i-score}
\subsubsection{Architecture}
\subsubsection{Problèmes actuels}
\subsubsection{Portabilité}
Après avoir enlevé la dépendance à Jamoma, on obtient l'exécution sur Android et iOS.

Le logiciel marche donc sur toute les plate-formes courantes.
    
\subsection{Extensions à i-score}
\subsubsection{Édition répartie}
Lien: \url{https://github.com/OSSIA/iscore-addon-network}~\\
Cette extension permet à plusieurs instances d'i-score de partager le même scénario au moment de l'édition.

Ce dépôt contient aussi les bases des travaux de répartition de l'exécution.

\subsubsection{Audio}
Lien: \url{https://github.com/OSSIA/iscore-addon-audio}~\\

Contient: 
\begin{itemize}
    \item L'intégration avec la LibAudioStream.
    \item Les flux développés pour la bibliothèque (Send et Return).
    \item Les processus i-score correspondants.
    \item Une intégration avec le format de plug-in LV2.
\end{itemize} 

Utilise Faust et optionnellement la bibliothèque lilv pour LV2.

\subsubsection{Automation 3D}
Lien: \url{https://github.com/OSSIA/iscore-addon-autom3d}~\\
Contient un processus qui permet de décrire une automation sur un 
paramètre à trois dimensions via une spline cubique, et un widget 
permettant l'édition de cette automation en 3D.

Utilise la bibliothèque VTK.

\subsubsection{Espace}
Lien: \url{https://github.com/OSSIA/iscore-addon-space}~\\
Contient le processus Espace qui permet de définir des zones via 
des équations cartésiennes et des interactions entre ces zones.

Utilise la bibliothèque VTK.

\subsubsection{Image}
Lien: \url{https://github.com/OSSIA/iscore-addon-image}~\\

Offre un processus purement utilitaire, qui permet d'afficher 
une image dans un scénario i-score.

\subsubsection{Vidéo}
Lien: \url{https://github.com/OSSIA/iscore-addon-video}~\\

Offre un processus qui lit une vidéo de manière intégrée à la 
timeline i-score.

\subsubsection{Controle à distance}
Lien: \url{https://github.com/OSSIA/iscore-addon-remotecontrol}~\\

Expose une partie de l'exécution i-score via un protocole simple sur WebSockets, 
qui permet notamment de déclencher les points d'interaction à la volée.

Contient aussi une application simple pour tablette ou téléphone qui permet d'interagir
avec ce protocole pour permettre le déclenchement au moment ou les points d'interaction 
deviennent accessibles.

\subsubsection{Analyse statique}
Lien: \url{https://github.com/OSSIA/iscore-addon-staticanalysis}~\\
Contient le code utilisé pour : 
\begin{itemize}
    \item La traduction en automates temporisés de l'article JNMR.
    \item Un algorithme de génération aléatoire de scénario i-score.
    \item Des outils de mesure de métriques de code appliqués aux scénarios i-score, notamment les métriques de complexité de Halstead.    
\end{itemize}

\subsubsection{Extension "Preset"}
Lien: \url{https://github.com/OSSIA/iscore-addon-presetstate}~\\
Prototype permettant de charger un état via un fichier de configuration.

\subsubsection{PureData}
Lien: \url{https://github.com/jcelerier/iscore-addon-pd}~\\
Prototype permettant d'utiliser des patches PureData dans un scénario i-score. 
Pour l'instant ne gère que des patchs avec une entrée et une sortie fixe.
Utilise libpd.

\subsubsection{Segments}
Lien: \url{https://github.com/OSSIA/iscore-addon-segments}~\\
Doit servir de base pour la brique d'intégration entre i-score et le projet Segments.
Pour l'instant contient juste un exemple d'utilisation de quelques interfaces d'i-score.


\subsection{libossia}
\subsubsection{Architecture}
\subsubsection{Problèmes actuels}
- temps de compilation
\subsubsection{Portages}
\paragraph{C}
\paragraph{Csharp et Unity}
\paragraph{Qt}
\paragraph{Java}
\paragraph{Javascript}
\subsection{OSCQuery}
\subsection{coppa}

\subsection{Études et développements mineurs}
\subsubsection{External RealSense}
\subsubsection{Outils pour graphe de calcul}
\paragraph{DisPATCH}
\paragraph{RaftLib}

\subsubsection{Contribution à d'autres projets open-source}
\paragraph{LibAudioStream}
\paragraph{FAUST}
\paragraph{Jamoma}
\paragraph{Contributions mineures}
\begin{itemize}
\item Placeholder/Nodeeditor
\item verdigris
\item fmt
\item Qt-color-widgets
\item jni.hpp
\item quazip
\item QRecentFilesMenu
\item ModernMIDI
\item libsamplerate
\item ofxMSAPhysics
\item Cotire
\end{itemize}

\section{Projets liés}

\subsection{Audio}

\subsubsection{Stage Magali Chauvat}
\paragraph{Objectifs}

- Il faut encore faire la brique d'intégration dans i-score
\subsection{Robots}
\subsubsection{Stage Nicolas 2015}
\subsubsection{Stage Kinda Al Chahid 2015}

\subsubsection{Stage Paul Breton 2016}
\subsubsection{Stage Maëva 2016}

\subsubsection{Projet TM - Robot 2015 - 2016}
\paragraph{Objectifs}
\paragraph{Groupe TM}
\paragraph{Groupe Robots}

\subsubsection{Projet TM - Robot 2016 - 2017}
\paragraph{Objectifs}
\paragraph{Groupe TM}
\paragraph{Groupe Robots}

\subsubsection{PFA2016 - 2017}
\paragraph{Objectifs}

\section{Cours et TDs donnés}
\subsection{TIM}
\subsection{TAP}

\chapter{Objectifs à venir}
\section{Système réparti}
\subsection{Exécution répartie}
\subsection{Répartition des protocoles}

\section{Audio}
\subsection{Article dans CMJ ?}
Pour que ce soit convainquant : offrir en plus la possibilité 
de réutiliser les flux passés. Et bien tout modéliser.

\begin{itemize}
\item Utiliser la modélisation de la LibAudioStream (Flux) ?
\item Utiliser la modélisation de OSSIA (Petri) ?
\end{itemize}

\subsection{Signatures temporelles}
\subsection{Support audio étendu}
- Gestion des pistes (entrées / sorties virtuelles comme dans un vrai séquenceur)
- Intégration travail TrackListModel de Magali
- Spatialisation / autre chose que stéréo
-> pistes de sortie 1, 2, 3, N canaux 

\subsection{Question des queues de reverb}
Possibilité : 
\begin{itemize}
\item Au début, lire tous les streams à l'infini dès qu'ils commencent.
\item Question des boucles ? que doit-il se passer ? 
\end{itemize}
Dans un DAW normal on boucle la lecture de contenu (fichiers audio, notes midi), mais les effets 
sont hors de la boucle.

Ici les deux choses sont possibles, c'est à l'auteur de choisir 
(en mettant les effets dans la boucle ou hors de la boucle).

- Compensation de délai : certains effets (compresseur, limiteur, certaines réverbs) impliquent 
un délai dans le traitement du signal.
La plpuart des DAW compensent ce délai au prix d'une latence d'entrée plus élevée : les autres 
pistes sont décalées de manière à tenir compte du délai des plug-ins.
Ableton Live offre le choix : compenser le délai ou avoir une latence d'entrée plus faible.
Si le délai n'est pas prix en compte, deux pistes qui étaient synchronisées à la base ne le seront plus 
après application de l'effet, ce qui peut poser problème pour des sections rythmiques par exemple.

Certains types d'effets préviennent à l'avance du décalage imposé, tandis que d'autres non.
Par exemple:
- Les effets VST supportent un délai statique (fixé au chargement du plug-in)
- Les effets Reaper, Pro Tools supportent un délai dynamique.
- Ce doit être fait manuellement par l'auteur pour FaUST.


\subsubsection{VST / VSTi}
\subsubsection{LV2}
Format de plug-ins qui permet l'analyse en temps réel de données.

\section{Embedding de i-score}
\subsection{DLL dans d'autres moteurs d'exécution}
\subsubsection{Max}
\subsubsection{VST}
\subsubsection{Unity}
\subsection{Scénarios compilés}
\subsection{Web}

\subsection{IncludeOS pour devices?}

\section{Unification temps - espace}
- Lister les cas possibles : comprendre 
ce que "appliquer les structures de i-score dans l'espace" veut dire.
Ex : 
\begin{itemize}
\item Si on considère qu'une contrainte temporelle est toujours sur une seule dimension, de temps ?
\item Si on considère qu'une contrainte temporelle est toujours sur une seule dimension, d'espace ? 
\item Si on considère qu'une contrainte temporelle est sur plusieurs dimensions d'espace ? 
\item Si on considère qu'une contrainte temporelle est sur toutes les dimensions à la fois (on fait "progresser" l'espace temps et on arrive dans des espaces différents selon les outcome du scénario i-score).
\item Si on considère non pas l'avancement dans un scénario comme quelque chose de global, mais quelque chose de lié à un acteur.
On a dès lors besoin de multiples curseurs de temps.
\end{itemize}

Alternative "intégration dans unity" : on applique à un objet existant dans Unity, un scénario i-score.
Ce scénario devrait pouvoir interagir avec le reste des paramètres ? On voit juste un aspect d'un scénario global ?

\section{Modèle par graphe de noeuds pour calcul par tranches}
On veut à chaque instant (tick) avoir un graphe de calcul différent, en fonction des processus qui sont exécutés.

%TODO -> faire petit schéma.

Il faut : 
\begin{itemize}
    \item Changer le moteur d'exécution afin qu'il fonctionne réellement sous la forme d'un graphe.
    \item Changer l'implémentation des processus et le type \lstinline|ossia::state| pour qu'ils renvoient un calcul à effectuer plutôt que le résultat de ce calcul ; c'est une forme d'évaluation paresseuse.
    \item Changer les processus pour qu'ils spécifient les adresses qu'ils utilisent en entrée - sortie.
    Par exemple pour le processus Javascript cela permettrait d'activer le listening sur les adresses qu'il utilise en entrée, 
    plutôt que de faire un "pull" dessus qui peut être plus long.
\end{itemize}

\section{Édition à l'exécution}
Actuellement, les structures de données utilisée à l'exécution sont recréées à chaque fois que le bouton "exécuter" est pressé.
C'est du au fait que les structures de données de l'API OSSIA ne sont pas thread-safe : il est actuellement dangereux de changer par exemple 
la durée d'une contrainte pendant qu'elle s'exécute car ces deux choses se font dans des threads distincts.

La première possibilité est de rajouter des mutex aux endroits impactés par l'édition 
(c'est à dire à peu près partout).

La seconde (ayant ma préférence) est d'utiliser une file de commandes pour l'édition : 
des commandes d'édition sont envoyées et mise dans une file sans verouillage (lock-free queue).

Le moteur d'exécution peut appliquer les commandes d'édition dans le cadre de sa boucle d'exécution, 
une fois que le tick d'exécution courant est terminé.
Cela permet de garder les performances du code sans mutex, tout en prévenant les crashs.

Par la suite, il est nécessaire de changer la manière dont l'API est appelée depuis i-score
pour qu'elle garde les structures en mémoire plutôt que de les recréer à chaque exécution, 
et qu'elle réagisse aux changements dans l'interface graphique.

Une perspective intéressante serait d'offrir par la suite une API d'édition par le réseau (OSC) 
ou via Javascript, pour pouvoir écrire des partitions auto-génératives.

\section{Polyphonie}
- Faire une liste des évènements communs à tous les types de polyphonie
\subsection{Polyphonie dans les scénarios}
On voudrait qu'une boite puisse être exécutée en même temps par plusieurs curseurs.
\begin{itemize}
	\item Comment l'écrire ? actuellement il n'y a qu'un curseur de temps. Faut-il introduire des exécutions parallèles sur le même scénario ?
	\item Peut-on synchroniser ces exécutions parallèles, avec les outils dont on dispose ? 
	\item Peut-on mettre en parallèle avec le travail sur la répartition : plusieurs scénarios s'exécutent indépendamment ? Problème de l'approche : on fixe à l'avant les utilisateurs ? Ou pas...
	\item Problématique : "stateful processes". Par exemple un tween. 
	\item Ce n'est pas utile d'émettre des informations sur les mêmes adresses. Pour la polyphonie il est nécessaire de paramétrer les adresses. Ne peut-on pas le faire avec un script JS par exemple ?
	\item Y-a-t-il des processus qui pourraient avoir du sens uniquement de manière polyphonique ? 
	\begin{itemize}
		\item Automations : il faut que les adresses soient différentes. Si on a n participants, on peut mappers aux adresses [1; n]. e.g. foo.0, foo.1, ... avec le système d'instances ?  Sinon il faut scripter... objet qui déduplique ? mais on se retrouve avec Max.
		\item Interpolations : il faut que les adresses soient différentes
		\item Mapping : il faut que les adresses soient différentes
		\item JS -> avoir un tableau avec tous les curseurs de temps en entrée ? Ou exécuter chaque script de manière indépendante ?
		\item Scénarios, boucles : récursivité
		\item Space : multi-pointeurs
		\item Fichier son : bof.
		\item Effect : bof.
		\item "Group" mappings (cf rapport master). Mapping $[1 \rightarrow n]$, $[n \rightarrow 1]$, $[n \rightarrow n]$, $[m \rightarrow n]$
	\end{itemize}
\end{itemize}
Deux cas : 

\begin{itemize}
\item Cas d'un scénario maître avec plein de petits scénarios esclaves : téléphones ? 
\item Cas de scénarios entièrement indépendants dans l'exécution : qu'est-ce qu'on y gagne par rapport à lancer plusieurs fois i-score.
\end{itemize}

Si on s'autorise des curseurs spatiaux.
Plusieurs scénarios qui s'exécutent.

Possibilité de déclarer un curseur à partir de n'importe quel noeud de l'arbre.

\subsection{Polyphonie dans l'espace}
- interaction entre deux agents / utilisateurs

\subsection{Polyphonie dans le son}
Première étape : piste virtuelle.

Buffers d'entrée : sorte de polyphonie ?
- plusieurs sons
- plusieurs auditeurs
\subsection{Spatialisation du son}
- plusieurs enceintes
En général deux méthodes :
- Spatialisation par piste
- Spatialisation par objet
- Intégration temps / espace
\section{Scripting de l'interface en Javascript}

\section{Interaction}
- Extraction des informations.
Informations de quoi ? Les dataspace le font déjà dans un sens.

\section{Langage}
Modéliser les développements réalisés via un langage.

Approche escomptée : langage réactif ou les variables sont des processus.

Comment le langage peut-il rendre compte de l'aspect "plug-in" du logiciel ? 

Très dur de faire un langage extensible au niveau de la syntaxe / sémantique ...

Approche DSL dans un langage existant ?

Le langage doit-il produire un scénario i-score ou bien directement s'exécuter ? 

Compiler en code C++ qui correspond ? 

\section{Problématiques d'UI / de développement}
- Afficher un processus sous plusieurs aspects (e.g. pour une courbe 3D, les automations x, y, z ainsi que l'allure générale que ça donne).
- Alias dans arbre (par exemple trois noeuds addrR, addrG, addrB => une seule addresse addr)
- Problématique de l'édition réciproque.
\subsection{Dataspace}
- Gérer les dataspace qui wrap (0 -> 360)
\subsection{Plug-in marketplace}
\subsection{Bibliothèque}

\section{Lien entre différents aspects}
Comment spatialiser un son efficacement en combinant les processus espace, etc.

Comment tout exécuter dans navigateur : il faut du webaudio pour la libaudiostream.

\subsection{Objets sonores interactifs}
-Objets sonores interactifs "self-contained"
-> "Chien qui aboie" 
-> Tonneau qui tombe; une fois qu'il est tombé, on ne peut plus interagir avec (jusqu'à quand?).

-> On doit pouvoir les échanger, les stocker...
-> Des fichiers sons peuvent être associés.
-> Question de propriété intellectuelle ? 
Empêcher l'édition et ne laisser que certains paramètres accessibles.
%\section{Objectifs personnels}
\chapter{Conclusion}
\section{Emploi du temps}
\section{Discussion}

\end{document}
